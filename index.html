<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris 2D ‚Äî Feel, Som e IA (1000+ linhas)</title>
  <style>
    /* ------------------------------------------------------------------
       TETRIS 2D ‚Äî FEEL + SOM + IA
       - Visual simples 2D com Three.js em modo ortogr√°fico
       - Sem depend√™ncias externas al√©m de Three.js
       - Efeitos "feel": shake, flash, squash, ghost, p√≥s-colis√£o, highlights
       - UI de m√∫sica/SFX/volumes, HUD com recordes e m√©tricas
       - IA opcional com heur√≠stica cl√°ssica (melhorada)
       - 1000+ linhas com coment√°rios para f√°cil manuten√ß√£o
       ------------------------------------------------------------------ */

    :root{
      --fg:#e0e3f0;
      --bg1:#0a0d1a;
      --accent:#7aa2ff;
      --ui-bg:#111529;
      --ui-border:rgba(122,162,255,.25);
      --danger:#ff6b6b;
      --ok:#70ff95;
      --muted:#9fb6ff;
      --panel-blur: 6px;
    }

    html, body { height:100%; margin:0; background: var(--bg1); color:var(--fg);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }

    canvas { display:block; }

    .panel { position: fixed; left: 10px; top: 10px; padding: 12px 14px; display: grid; gap: 8px;
      background: color-mix(in srgb, var(--ui-bg) 86%, transparent);
      backdrop-filter: blur(var(--panel-blur));
      border:1px solid var(--ui-border); border-radius: 12px; }

    #hud h1 { font-size: 16px; margin: 0 0 4px; letter-spacing: .5px; color: var(--accent); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .stat { font-size: 12px; opacity: .95; }
    .keys { font-size: 11px; opacity: .85; line-height: 1.35; margin-top: 6px; }
    .pill { border:1px solid var(--ui-border); padding: 6px 8px; border-radius: 10px; font-size: 12px; cursor: pointer; user-select: none; transition: background-color .15s, transform .05s; }
    .pill:hover { background: rgba(122,162,255,.1); }
    .pill:active { transform: translateY(1px); }
    .pill[aria-pressed="true"]{ background: rgba(122,162,255,.2); }

    #aiControl { top: auto; bottom: 10px; gap: 10px; }
    #aiControl label { font-size: 12px; display: flex; align-items: center; gap: 6px; }
    #speedSlider { width: 140px; }

    #rightPanel { position: fixed; right: 10px; top: 10px; display: grid; gap:10px; }
    .card { background: var(--ui-bg); border:1px solid var(--ui-border); border-radius: 12px; padding: 10px 12px; min-width: 150px; }
    .card h2 { margin: 0 0 8px; font-size: 12px; font-weight: 600; color: var(--accent); letter-spacing: .3px; }
    .mini { width: 140px; height: 140px; background: rgba(122,162,255,.04); border-radius: 10px; border:1px dashed var(--ui-border); display:grid; place-items:center; }

    #pauseOverlay { pointer-events: none; position: fixed; inset: 0; display: grid; place-items: center; color: #cfe3ff; font-weight: 800;
      font-size: clamp(18px, 4vw, 42px); text-shadow: 0 2px 10px rgba(0,0,0,.6); opacity: 0; transition: opacity .25s ease; }
    #pauseOverlay.show { opacity: 1; }

    #gameover { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.6); color: #fff; text-align: center; }
    #gameover .card { background: #111529; padding: 20px 22px; border-radius: 14px; min-width: 280px; }
    #gameover button { margin-top: 12px; padding: 9px 12px; border-radius: 10px; border: 0; background: #5a6cff; color: #fff; font-weight: 700; cursor: pointer; }

    #audioPanel { position: fixed; left: 10px; top: 200px; display: grid; gap: 8px;
      background: var(--ui-bg); border:1px solid var(--ui-border); border-radius: 12px; padding: 12px; }
    #audioPanel label { font-size: 12px; display:flex; align-items:center; gap:8px; justify-content: space-between; }
    #audioPanel input[type="range"]{ width: 160px; }

    .hint { font-size: 11px; opacity: .75; }
    .ok { color: var(--ok); }
    .danger { color: var(--danger); }

    .badge { font-size: 10px; border:1px solid var(--ui-border); padding:2px 6px; border-radius: 8px; opacity:.9; }

    #toast { position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%);
      background: rgba(13,16,32,.88); color: var(--fg); border: 1px solid var(--ui-border); padding: 10px 14px; border-radius: 12px; font-size: 12px;
      opacity: 0; pointer-events: none; transition: opacity .25s, transform .25s; }
    #toast.show { opacity: 1; transform: translate(-50%, -6px); }
  </style>

  <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js" } }</script>
</head>
<body>
  <div id="hud" class="panel">
    <h1>Tetris 2D</h1>
    <div class="row">
      <div class="stat">Pontua√ß√£o: <span id="score">0</span></div>
      <div class="stat">Linhas: <span id="lines">0</span></div>
      <div class="stat">N√≠vel: <span id="level">1</span></div>
      <div class="stat">Vel.: <span id="speed">1.00x</span></div>
      <div class="stat">Combo: <span id="combo">0</span></div>
      <div class="stat">Recorde: <span id="hiscore">0</span></div>
    </div>
    <div class="row">
      <div id="btnMusic" class="pill" role="button" aria-pressed="false" title="Ativar/Desativar m√∫sica (M)">üéµ M√∫sica</div>
      <div id="btnSfx" class="pill" role="button" aria-pressed="true" title="Ativar/Desativar SFX (N)">üîä SFX</div>
      <div id="btnPause" class="pill" role="button" aria-pressed="false" title="Pausa (P)">‚è∏ Pausa</div>
      <div id="btnTheme" class="pill" role="button" aria-pressed="false" title="Alternar tema">üé® Tema</div>
      <div class="badge" id="statusBadge">OK</div>
    </div>
    <div class="keys">
      ‚Üê/‚Üí mover ‚Ä¢ ‚Üì descer ‚Ä¢ ‚Üë/Z rodar ‚Ä¢ Espa√ßo queda r√°pida ‚Ä¢ C Hold ‚Ä¢ P Pausa ‚Ä¢ R Reiniciar ‚Ä¢ M M√∫sica ‚Ä¢ N SFX ‚Ä¢ G Gamepad
    </div>
  </div>

  <div id="audioPanel" class="panel">
    <div class="row" style="justify-content:space-between;align-items:center">
      <strong style="font-size:12px;color:var(--accent)">√Åudio & Feel</strong>
      <span class="hint">WebAudio</span>
    </div>
    <label>Volume M√∫sica <input id="musicVol" type="range" min="0" max="100" value="35"></label>
    <label>Volume SFX <input id="sfxVol" type="range" min="0" max="100" value="65"></label>
    <label>Shake <input id="shakeStrength" type="range" min="0" max="100" value="60"></label>
    <label>Squash <input id="squashStrength" type="range" min="0" max="100" value="70"></label>
    <label>Flash <input id="flashStrength" type="range" min="0" max="100" value="40"></label>
    <div class="hint">Dica: ajusta o "feel" a teu gosto. Tudo corre no mesmo loop, sem libs extra.</div>
  </div>

  <div id="aiControl" class="panel">
    <label><input type="checkbox" id="aiToggle"> <strong>Ativar IA</strong></label>
    <label>Velocidade IA: <span id="speedLabel">50</span></label>
    <input type="range" id="speedSlider" min="1" max="100" value="50">
    <div class="hint">A IA joga automaticamente usando heur√≠stica (altura, buracos, bumpiness e linhas).</div>
  </div>

  <div id="rightPanel">
    <div class="card"><h2>Pr√≥xima</h2><div class="mini"><canvas id="nextCanvas" width="128" height="128"></canvas></div></div>
    <div class="card"><h2>Hold</h2><div class="mini"><canvas id="holdCanvas" width="128" height="128"></canvas></div></div>
    <div class="card">
      <h2>Indicadores</h2>
      <div class="stat">Tempo: <span id="playtime">0:00</span></div>
      <div class="stat">APM: <span id="apm">0</span></div>
      <div class="stat">Pe√ßas: <span id="pieces">0</span></div>
      <div class="stat">FPS: <span id="fps">0</span></div>
    </div>
  </div>

  <div id="pauseOverlay">PAUSA</div>
  <div id="gameover"><div class="card"><div style="font-size:22px;margin-bottom:6px">Jogo Terminado</div>
    <div style="opacity:.85">Pressiona <b>R</b> para recome√ßar</div>
    <button id="restartBtn">Reiniciar</button></div></div>

  <div id="toast">Guardado!</div>

  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'three';

    /* =====================================================================
       CONFIGURA√á√ïES GERAIS
       ===================================================================== */
    const COLS = 10, ROWS = 20;
    const DROP_BASE_MS = 820;            // queda base
    const SPEED_INC = 0.90;              // multiplicador por n√≠vel
    const LINES_PER_LEVEL = 10;          // linhas por n√≠vel
    const VIEW_MARGIN = 1.2;             // margem √† volta do tabuleiro

    const GRID_COLOR = 0x2d3b88;
    const TOPLINE_COLOR = 0xff6b6b;

    // Paleta para pe√ßas (pastel vibrante)
    const colors = [ 0x48c7ff, 0xffe777, 0xff7ad9, 0x70ff95, 0xff7474, 0x8da7ff, 0xffb173 ];

    // Formas e rota√ß√µes (normalizadas 4 estados para simplificar)
    const SHAPES = {
      I: [ [[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]] ],
      O: [ [[1,1],[2,1],[1,2],[2,2]] ],
      T: [ [[1,1],[0,1],[2,1],[1,2]], [[1,1],[1,0],[1,2],[2,1]], [[1,1],[0,1],[2,1],[1,0]], [[1,1],[1,0],[1,2],[0,1]] ],
      S: [ [[1,1],[2,1],[0,2],[1,2]], [[1,0],[1,1],[2,1],[2,2]] ],
      Z: [ [[0,1],[1,1],[1,2],[2,2]], [[2,0],[1,1],[2,1],[1,2]] ],
      J: [ [[0,1],[0,2],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,0]], [[1,0],[1,1],[1,2],[0,2]] ],
      L: [ [[2,1],[0,1],[1,1],[2,2]], [[1,0],[1,1],[1,2],[2,2]], [[0,0],[1,1],[2,1],[0,1]], [[0,0],[1,0],[1,1],[1,2]] ],
    };
    for (const key in SHAPES) {
      if (SHAPES[key].length === 1) SHAPES[key].push(...SHAPES[key], ...SHAPES[key], ...SHAPES[key]);
      else if (SHAPES[key].length === 2) SHAPES[key].push(...SHAPES[key]);
    }
    const BAG = ['I','O','T','S','Z','J','L'];

    /* =====================================================================
       √ÅUDIO ‚Äî ENGINE (WebAudio)
       - M√∫sica gerada proceduralmente (padr√µes simples "chiptune")
       - SFX para a√ß√µes (mover, rodar, cair, bloquear, linhas, n√≠vel, hold...)
       - Sem depend√™ncias externas. Tudo controlado por par√¢metros.
       ===================================================================== */
    let audioCtx = null;
    let musicOn = false, sfxOn = true;
    let musicTimer = null;
    const musicState = {
      bpm: 132,
      step: 0,
      baseGain: 0.05,
      swing: 0.04,
      playing: false,
      seqLen: 64,
      patternA: [ // melodia
        659, 0, 523, 587, 659, 587, 523, 494,
        392, 440, 494, 523, 440, 494, 523, 587,
        659, 0, 523, 587, 659, 784, 698, 659,
        587, 523, 440, 0,   494, 523, 587, 659,
        587, 0, 523, 587, 659, 587, 523, 494,
        392, 440, 494, 523, 440, 494, 523, 587,
        523, 0, 494, 523, 587, 659, 587, 523,
        494, 440, 392, 0,   392, 440, 494, 523
      ],
      patternB: [ // baixo
        196,196,196,196, 247,247,247,247, 220,220,220,220, 196,196,196,196,
        196,196,196,196, 247,247,247,247, 220,220,220,220, 196,196,196,196
      ],
      patternDr: [ // percuss√£o (ru√≠do)
        1,0,0,0,  0,1,0,0,  1,0,0,0,  0,1,0,0,
        1,0,0,0,  0,1,0,0,  1,0,0,0,  1,0,1,0
      ]
    };

    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Utilit√°rios de √°udio
    function noteLen(beats=1){
      const spb = 60 / musicState.bpm; // seconds per beat
      return beats * spb;
    }

    function schedule(fn, when){
      // Pequeno agendador baseado no currentTime do AudioContext
      try { fn(when); } catch(e){}
    }

    function gainNode(value){
      const g = audioCtx.createGain();
      g.gain.value = value;
      return g;
    }

    function osc(freq=440, type='square'){
      const o = audioCtx.createOscillator();
      o.type = type; o.frequency.value = freq; return o;
    }

    function whiteNoise(){
      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i=0; i<bufferSize; i++) output[i] = Math.random()*2-1;
      const node = audioCtx.createBufferSource(); node.buffer = noiseBuffer; node.loop = false; return node;
    }

    function envADSR(dest, when, a=0.005, d=0.08, s=0.25, r=0.12, peak=1.0){
      // Cria um ganho com envelope ADSR simples
      const g = audioCtx.createGain();
      g.gain.cancelScheduledValues(when);
      g.gain.setValueAtTime(0.0001, when);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak), when + a);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak*s), when + a + d);
      g.gain.setTargetAtTime(0.0001, when + a + d + 0.0001, r);
      g.connect(dest);
      return g;
    }

    // SFX ---------------------------------------------------------------
    const SFX = {
      vol: 0.65, // multiplicador (0..1)
      move(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(460,'square'); const g=envADSR(audioCtx.destination,t,0.002,0.06,0.15,0.08,0.08*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.09); },
      rotate(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(620,'square'); const g=envADSR(audioCtx.destination,t,0.002,0.06,0.15,0.08,0.10*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.11); },
      soft(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(380,'triangle'); const g=envADSR(audioCtx.destination,t,0.001,0.04,0.2,0.06,0.09*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.08); },
      drop(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(240,'sawtooth'); const g=envADSR(audioCtx.destination,t,0.001,0.05,0.25,0.08,0.16*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.12); },
      lock(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const n=whiteNoise(); const g=envADSR(audioCtx.destination,t,0.001,0.05,0.2,0.07,0.20*SFX.vol); n.connect(g); n.start(t); n.stop(t+0.08); },
      line(n=1){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; for(let i=0;i<n;i++){ const o=osc(700+i*50,'square'); const g=envADSR(audioCtx.destination,t+i*0.03,0.002,0.06,0.2,0.08,0.14*SFX.vol); o.connect(g); o.start(t+i*0.03); o.stop(t+i*0.09); } },
      level(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; [880,988,1046].forEach((f,i)=>{ const o=osc(f,'triangle'); const g=envADSR(audioCtx.destination,t+i*0.06,0.002,0.08,0.2,0.12,0.18*SFX.vol); o.connect(g); o.start(t+i*0.06); o.stop(t+i*0.14); }); },
      hold(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(300,'triangle'); const g=envADSR(audioCtx.destination,t,0.002,0.06,0.2,0.1,0.12*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.12); },
      pause(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(500,'sine'); const g=envADSR(audioCtx.destination,t,0.002,0.06,0.2,0.08,0.08*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.10); },
      unpause(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(650,'sine'); const g=envADSR(audioCtx.destination,t,0.002,0.06,0.2,0.08,0.10*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.10); },
      gameover(){ if(!sfxOn||!audioCtx) return; const t=audioCtx.currentTime; const o=osc(220,'sawtooth'); const g=envADSR(audioCtx.destination,t,0.01,0.2,0.3,0.6,0.30*SFX.vol); o.connect(g); o.start(t); o.stop(t+0.9); }
    };

    // M√∫sica -------------------------------------------------------------
    function startMusic(){
      ensureAudio();
      if (musicState.playing) return; musicState.playing = true; musicOn = true;
      document.getElementById('btnMusic').setAttribute('aria-pressed','true');

      const spb = 60/musicState.bpm; // seconds per beat
      const subdivision = 0.5;       // colcheias
      const interval = spb*subdivision;

      function tick(){
        if (!musicState.playing) return;
        const t = audioCtx.currentTime;
        const step = musicState.step % musicState.seqLen;

        const melFreq = musicState.patternA[step % musicState.patternA.length] || 0;
        const bassFreq = musicState.patternB[step % musicState.patternB.length] || 0;
        const dr = musicState.patternDr[step % musicState.patternDr.length] || 0;

        const swing = (step%2===1) ? musicState.swing*interval : 0;
        const when = t + 0.02 + swing;

        // Melodia
        if (melFreq>0){
          const o = osc(melFreq,'square');
          const g = envADSR(audioCtx.destination, when, 0.002, 0.08, 0.35, 0.10, musicState.baseGain * musicVol);
          o.connect(g); o.start(when); o.stop(when + interval*1.4);
        }
        // Baixo
        if (bassFreq>0){
          const o = osc(bassFreq,'triangle');
          const g = envADSR(audioCtx.destination, when, 0.003, 0.12, 0.45, 0.12, 0.6*musicState.baseGain * musicVol);
          o.connect(g); o.start(when); o.stop(when + interval*1.6);
        }
        // Bateria (ru√≠do curto)
        if (dr){ const n = whiteNoise(); const g = envADSR(audioCtx.destination, when, 0.001, 0.05, 0.2, 0.10, 0.35*musicState.baseGain * musicVol); n.connect(g); n.start(when); n.stop(when + 0.08); }

        musicState.step++;
        musicTimer = setTimeout(tick, interval*1000);
      }
      tick();
    }

    function stopMusic(){ musicOn=false; musicState.playing=false; document.getElementById('btnMusic').setAttribute('aria-pressed','false'); if(musicTimer){ clearTimeout(musicTimer); musicTimer=null; } }

    let musicVol = 0.35; // 0..1

    // Beeps simples para intera√ß√µes fora da m√∫sica
    function uiBeep(freq=520, dur=0.06, type='square', gain=0.05){
      try{ ensureAudio(); const o=osc(freq,type); const g=audioCtx.createGain(); g.gain.value=gain*musicVol; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur); }catch(e){}
    }

    /* =====================================================================
       THREE.JS ‚Äî CENA 2D
       ===================================================================== */
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-10,10,10,-10,-10,10);
    camera.position.set(0, ROWS/2, 5); camera.lookAt(0, ROWS/2, 0);

    function fitOrtho(){
      const aspect = window.innerWidth/window.innerHeight;
      const w = COLS + VIEW_MARGIN*2, h = ROWS + VIEW_MARGIN*2;
      const boardAspect = w/h; let halfW, halfH;
      if(aspect > boardAspect){ halfH = h/2; halfW = halfH*aspect; }
      else { halfW = w/2; halfH = halfW/aspect; }
      camera.left = -halfW; camera.right = halfW; camera.top = ROWS/2 + halfH - (ROWS/2); camera.bottom = ROWS/2 - halfH - (ROWS/2);
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); fitOrtho(); });

    // Grupos principais
    const boardGroup = new THREE.Group(); scene.add(boardGroup);

    // Grelha
    const grid = new THREE.Group(); const lineMat = new THREE.LineBasicMaterial({color:GRID_COLOR, transparent:true, opacity:.35});
    for(let y=0;y<=ROWS;y++){
      const geo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(-COLS/2, y, 0), new THREE.Vector3(COLS/2, y, 0) ]);
      grid.add(new THREE.Line(geo, lineMat));
    }
    for(let x=-COLS/2;x<=COLS/2;x++){
      const geo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(x, 0, 0), new THREE.Vector3(x, ROWS, 0) ]);
      grid.add(new THREE.Line(geo, lineMat));
    }
    boardGroup.add(grid);

    // Linha do topo (game over quando cruzada)
    const topGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(-COLS/2, ROWS, 0), new THREE.Vector3(COLS/2, ROWS, 0) ]);
    const topLineMat = new THREE.LineBasicMaterial({color:TOPLINE_COLOR, transparent:true, opacity:.8});
    const topLine = new THREE.Line(topGeo, topLineMat); boardGroup.add(topLine);

    // Geometrias/grupos
    const tileGeo = new THREE.PlaneGeometry(.98, .98);
    const stackGroup = new THREE.Group(); stackGroup.position.set(-COLS/2 + .5, .5, 0); boardGroup.add(stackGroup);
    const activeGroup = new THREE.Group(); activeGroup.position.copy(stackGroup.position); boardGroup.add(activeGroup);
    const ghostGroup  = new THREE.Group(); ghostGroup.position.copy(stackGroup.position); boardGroup.add(ghostGroup);
    const fxGroup     = new THREE.Group(); fxGroup.position.copy(stackGroup.position); boardGroup.add(fxGroup);

    // Efeito: flash do fundo
    let flashIntensity = 0; // 0..1

    /* =====================================================================
       ESTADO DO JOGO
       ===================================================================== */
    let board = Array.from({length: ROWS}, ()=>Array(COLS).fill(null));
    let bag = [];
    let piecesCount = 0;
    function nextFromBag(){ if(bag.length===0){ bag = BAG.slice(); for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; } } return bag.pop(); }
    function peekNext(){ if(bag.length===0) return 'I'; return bag[bag.length-1]; }
    function newPiece(){ const type = nextFromBag(); const rot=0; const color = colors[BAG.indexOf(type)]; piecesCount++; return { type, rot, x: 3, y: 18, color, lockDelay:0 }; }

    let piece = newPiece(); let hold = null, holdLocked=false;
    let score=0, lines=0, level=1; let dropMs = DROP_BASE_MS; let dropAcc=0; let softDrop=false; let paused=false; let gameover=false;
    let combo = 0; let hiscore = Number(localStorage.getItem('t2d_hiscore')||0);
    let startTime = performance.now(); let apm = 0; let lastActions = [];

    // Guarda recorde
    function saveHiscore(){ try{ localStorage.setItem('t2d_hiscore', String(hiscore)); toast('Recorde guardado'); }catch(e){} }

    /* =====================================================================
       FEEL ENGINE ‚Äî anima√ß√µes simples (shake, squash, flash, spark)
       ===================================================================== */
    const Feel = {
      shakeAmp: 0.06, // escalado pelo slider
      shakeTime: 0,
      squashMap: new Map(), // key: mesh, value: {t, dur, sxFrom, sxTo, syFrom, syTo}
      sparks: [],          // pequenas fa√≠scas quadradas
      flashTime: 0,

      triggerShake(ms=120){ this.shakeTime = Math.max(this.shakeTime, ms); },
      triggerFlash(ms=180){ this.flashTime = Math.max(this.flashTime, ms); flashIntensity = 1; },
      addSquash(mesh, dur=120, sxFrom=1, sxTo=1.08, syFrom=1, syTo=0.92){ this.squashMap.set(mesh, {t:dur, dur, sxFrom, sxTo, syFrom, syTo}); },
      addSpark(x,y,color=0xffffff){ const m = new THREE.Mesh(new THREE.PlaneGeometry(.2,.2), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.95})); m.position.set(x,y,0.002); m.userData = {vx:(Math.random()*0.6-0.3), vy:(Math.random()*0.8+0.4), life:260}; fxGroup.add(m); this.sparks.push(m); },

      update(dt){
        // Shake (micro jitter do boardGroup)
        if (this.shakeTime>0){
          this.shakeTime -= dt;
          const a = (this.shakeTime>0)? (this.shakeTime/180) : 0;
          const amp = this.shakeAmp * (document.getElementById('shakeStrength').value/100);
          boardGroup.position.x = (Math.random()*2-1) * amp * a;
          boardGroup.position.y = (Math.random()*2-1) * amp * a * 0.6;
        } else {
          boardGroup.position.x = 0; boardGroup.position.y = 0;
        }

        // Squash (escala de malhas)
        for (const [mesh, s] of this.squashMap){
          s.t -= dt; const p = Math.max(0, 1 - s.t/s.dur);
          const sx = s.sxFrom + (s.sxTo - s.sxFrom)*easeOutCubic(p);
          const sy = s.syFrom + (s.syTo - s.syFrom)*easeOutCubic(p);
          mesh.scale.set(sx, sy, 1);
          if (s.t<=0){ mesh.scale.set(1,1,1); this.squashMap.delete(mesh); }
        }

        // Sparks
        if (this.sparks.length){
          for (let i=this.sparks.length-1;i>=0;i--){ const m=this.sparks[i]; const u=m.userData; u.life-=dt; m.material.opacity = Math.max(0, u.life/260); m.position.x += u.vx*(dt/16); m.position.y += u.vy*(dt/16); u.vy -= 0.015*(dt/16); if(u.life<=0){ fxGroup.remove(m); this.sparks.splice(i,1); } }
        }

        // Flash do fundo
        if (this.flashTime>0){ this.flashTime -= dt; flashIntensity = Math.max(0, this.flashTime/200); } else { flashIntensity = 0; }
      }
    };

    // Easing para as anima√ß√µes
    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

    /* =====================================================================
       FUN√á√ïES DE RENDERIZA√á√ÉO DAS PE√áAS E GHOST
       ===================================================================== */
    function mat(col, transparent=false, opacity=1){ return new THREE.MeshBasicMaterial({ color: col, transparent, opacity: transparent?opacity:1 }); }

    function buildPieceGroup(g, p, ghost=false){
      while(g.children.length) g.remove(g.children[0]);
      const m = ghost ? mat(p.color, true, 0.30) : mat(p.color, false);
      for(const [bx,by] of SHAPES[p.type][p.rot]){
        const sq = new THREE.Mesh(tileGeo, m);
        sq.position.set(p.x+bx, p.y+by, ghost? -0.001 : 0);
        g.add(sq);
      }
    }

    function refreshActiveMeshes(){ buildPieceGroup(activeGroup, piece, false); }

    function refreshGhost(){
      const g = projectGhost(piece);
      buildPieceGroup(ghostGroup, g, true);
    }

    function projectGhost(p){ const g={...p}; while(canMove(g,0,-1)) g.y--; return g; }

    function forEachBlock(p, fn){ for(const [bx,by] of SHAPES[p.type][p.rot]){ fn(p.x+bx, p.y+by); } }

    function canMove(p, dx, dy){ let ok=true; forEachBlock(p, (x,y)=>{ const nx=x+dx, ny=y+dy; if(nx<0||nx>=COLS||ny<0||(ny<ROWS && board[ny][nx])) ok=false; }); return ok; }

    function canRotate(p, dir){
      const test={...p, rot:(p.rot+dir+SHAPES[p.type].length)%SHAPES[p.type].length};
      let ok=true; forEachBlock(test,(x,y)=>{ if(x<0||x>=COLS||y<0||(y<ROWS && board[y][x])) ok=false; });
      if(!ok){
        // Pequenos "kicks" laterais
        const kicks=[[-1,0],[1,0],[-2,0],[2,0]];
        for(const [kx,ky] of kicks){
          const t2={...test,x:test.x+kx,y:test.y+ky}; let ok2=true; forEachBlock(t2,(x,y)=>{ if(x<0||x>=COLS||y<0||(y<ROWS && board[y][x])) ok2=false; });
          if(ok2){ Object.assign(test,t2); ok=true; break; }
        }
      }
      return ok?test:null;
    }

    function addCubeToStack(x,y,color){
      const m=mat(color,false); const sq=new THREE.Mesh(tileGeo,m); sq.position.set(x,y,0); stackGroup.add(sq);
      // Squash suave ao assentar
      Feel.addSquash(sq, 120, 1.0, 1.06, 1.0, 0.94);
      // Pequena fa√≠sca visual
      if (document.getElementById('squashStrength').value>0) Feel.addSpark(x,y,0xffffff);
    }

    function clearLines(){
      let toClear=[]; for(let y=0;y<ROWS;y++){ if(board[y].every(Boolean)) toClear.push(y); }
      if(!toClear.length) return 0;

      // Flash + shake proporcional √†s linhas
      const flashPower = Number(document.getElementById('flashStrength').value)/100;
      if (flashPower>0) Feel.triggerFlash(120 + 60*toClear.length);
      Feel.triggerShake(100 + 40*toClear.length);

      // SFX
      SFX.line(toClear.length);

      // Remove do estado l√≥gico
      board = board.filter((_,y) => !toClear.includes(y));
      for(let i=0; i<toClear.length; i++) board.push(Array(COLS).fill(null));

      // Reconstr√≥i a pilha visual
      while(stackGroup.children.length) stackGroup.remove(stackGroup.children[0]);
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) addCubeToStack(x,y,board[y][x]);
      return toClear.length;
    }

    function endGame(){
      gameover=true; paused=true; document.getElementById('gameover').style.display='grid'; if(aiTimer) clearTimeout(aiTimer);
      SFX.gameover();
      if (score>hiscore){ hiscore=score; saveHiscore(); updateHUD(); }
    }

    /* =====================================================================
       PONTUA√á√ÉO / N√çVEL / COMBO
       ===================================================================== */
    function onLinesCleared(n){
      if (n>0){
        combo++;
        const base=100; const comboBonus = 25*Math.max(0,combo-1);
        score += base * (2**(n-1)) * level + comboBonus;
        lines += n;
        const prevLevel = level;
        level = 1 + Math.floor(lines / LINES_PER_LEVEL);
        dropMs = DROP_BASE_MS * Math.pow(SPEED_INC, level-1);
        if (level>prevLevel) { SFX.level(); toast(`N√≠vel ${level}!`, 900); }
      } else {
        combo = 0;
      }
      updateHUD();
    }

    /* =====================================================================
       IA ‚Äî heur√≠stica
       ===================================================================== */
    let aiEnabled = false; let aiMoveDelay = 250; let aiTimer = null;
    const aiToggle = document.getElementById('aiToggle');
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');

    function updateAiSpeed() {
      const sliderValue = parseInt(speedSlider.value, 10);
      const maxDelay = 500, minDelay = 0;
      aiMoveDelay = maxDelay - ((sliderValue - 1) / 99) * (maxDelay - minDelay);
      speedLabel.textContent = sliderValue;
    }

    speedSlider.addEventListener('input', updateAiSpeed);
    aiToggle.addEventListener('change', () => {
      aiEnabled = aiToggle.checked; uiBeep(560,0.05);
      if (aiEnabled && !paused && !gameover) { scheduleNextAiMove(); }
      else if (!aiEnabled && aiTimer) { clearTimeout(aiTimer); aiTimer = null; }
    });

    function scheduleNextAiMove() { if (aiTimer) clearTimeout(aiTimer); aiTimer = setTimeout(executeAiMove, aiMoveDelay); }

    function executeAiMove() {
      if (!aiEnabled || paused || gameover) return;
      const bestMove = findBestMove(board, piece);
      if (bestMove) {
        piece.rot = bestMove.rot;
        piece.x = bestMove.x;
        refreshActiveMeshes();
        hardDrop(true); // IA usa hard drop
      } else { endGame(); }
    }

    function findBestMove(currentBoard, currentPiece) {
      let bestScore = -Infinity; let bestMove = null;
      for (let rot = 0; rot < SHAPES[currentPiece.type].length; rot++) {
        for (let x = -2; x < COLS; x++) {
          const testPiece = { ...currentPiece, rot, x };
          if (!canMove(testPiece, 0, 0)) continue;
          let landedPiece = {...testPiece}; while(canMove(landedPiece, 0, -1)) { landedPiece.y--; }
          const tempBoard = currentBoard.map(row => row.slice());
          forEachBlock(landedPiece, (px, py) => { if(py < ROWS) tempBoard[py][px] = 1; });
          const score = evaluateBoard(tempBoard);
          if (score > bestScore) { bestScore = score; bestMove = { rot: landedPiece.rot, x: landedPiece.x }; }
        }
      }
      return bestMove;
    }

    function evaluateBoard(boardState) {
      const AGGREGATE_HEIGHT_WEIGHT = -0.51, COMPLETED_LINES_WEIGHT = 0.76, HOLES_WEIGHT = -0.35, BUMPINESS_WEIGHT = -0.18;
      let aggregateHeight = 0, holes = 0, bumpiness = 0; const columnHeights = Array(COLS).fill(0);
      for (let c = 0; c < COLS; c++) { for (let r = ROWS - 1; r >= 0; r--) { if (boardState[r][c]) { columnHeights[c] = r + 1; break; } } aggregateHeight += columnHeights[c]; }
      for (let c = 0; c < COLS; c++) { for (let r = columnHeights[c] - 2; r >= 0; r--) { if (!boardState[r][c]) { holes++; } } }
      for (let i = 0; i < COLS - 1; i++) { bumpiness += Math.abs(columnHeights[i] - columnHeights[i+1]); }
      let completedLines = 0; for (let r = 0; r < ROWS; r++) { if (boardState[r].every(cell => cell)) { completedLines++; } }
      return AGGREGATE_HEIGHT_WEIGHT * aggregateHeight + COMPLETED_LINES_WEIGHT * completedLines * completedLines + HOLES_WEIGHT * holes + BUMPINESS_WEIGHT * bumpiness;
    }

    /* =====================================================================
       INPUT ‚Äî Teclado e Gamepad
       ===================================================================== */
    const heldKeys = new Set();
    let usingGamepad = false;

    window.addEventListener('keydown', (e)=>{
      if (e.repeat) return; heldKeys.add(e.key);
      if (aiEnabled) return;
      if(gameover && e.key.toLowerCase()!=='r') return;
      if(e.key==='p'||e.key==='P') { togglePause(); return; }
      if(paused) return;

      if(e.key==='ArrowLeft'){ if(canMove(piece,-1,0)){ piece.x--; refreshActiveMeshes(); refreshGhost(); SFX.move(); markAction(); } }
      else if(e.key==='ArrowRight'){ if(canMove(piece,1,0)){ piece.x++; refreshActiveMeshes(); refreshGhost(); SFX.move(); markAction(); } }
      else if(e.key==='ArrowDown'){ softDrop=true; SFX.soft(); }
      else if(e.key==='ArrowUp'){ const t=canRotate(piece,+1); if(t){ piece=t; refreshActiveMeshes(); refreshGhost(); SFX.rotate(); markAction(); } }
      else if(e.key==='z'||e.key==='Z'){ const t=canRotate(piece,-1); if(t){ piece=t; refreshActiveMeshes(); refreshGhost(); SFX.rotate(); markAction(); } }
      else if(e.code==='Space'){ hardDrop(); }
      else if(e.key==='c'||e.key==='C'){ holdPiece(); }
      else if(e.key==='r'||e.key==='R'){ restart(); }
      else if(e.key==='m'||e.key==='M'){ musicOn? stopMusic(): startMusic(); }
      else if(e.key==='n'||e.key==='N'){ sfxOn = !sfxOn; document.getElementById('btnSfx').setAttribute('aria-pressed', String(sfxOn)); uiBeep(sfxOn?650:400,0.05); }
      else if(e.key==='g'||e.key==='G'){ usingGamepad = !usingGamepad; toast(usingGamepad? 'Gamepad: ON' : 'Gamepad: OFF'); }
    });

    window.addEventListener('keyup', (e)=>{ heldKeys.delete(e.key); if (!aiEnabled && e.key==='ArrowDown') softDrop=false; });

    function pollGamepad(){
      if (!usingGamepad || aiEnabled || paused || gameover) return;
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = pads && pads[0]; if (!gp) return;
      const [lx, ly] = gp.axes || [0,0];
      const dead = 0.25;
      if (lx < -dead){ tryMove(-1); } else if (lx > dead){ tryMove(1); }
      if (gp.buttons[0] && gp.buttons[0].pressed){ hardDrop(); }
      if (gp.buttons[1] && gp.buttons[1].pressed){ const t=canRotate(piece,+1); if(t){ piece=t; refreshActiveMeshes(); refreshGhost(); SFX.rotate(); markAction(); } }
      if (gp.buttons[2] && gp.buttons[2].pressed){ const t=canRotate(piece,-1); if(t){ piece=t; refreshActiveMeshes(); refreshGhost(); SFX.rotate(); markAction(); } }
      if (gp.buttons[3] && gp.buttons[3].pressed){ holdPiece(); }
    }

    function tryMove(dx){ if(canMove(piece,dx,0)){ piece.x+=dx; refreshActiveMeshes(); refreshGhost(); SFX.move(); markAction(); } }

    document.getElementById('btnMusic').addEventListener('click', ()=> { musicOn? stopMusic(): startMusic(); });
    document.getElementById('btnSfx').addEventListener('click', ()=> { sfxOn = !sfxOn; document.getElementById('btnSfx').setAttribute('aria-pressed', String(sfxOn)); uiBeep(sfxOn?650:400,0.05); });
    document.getElementById('btnPause').addEventListener('click', ()=> togglePause());
    document.getElementById('btnTheme').addEventListener('click', ()=> toggleTheme());

    function togglePause(){
      paused=!paused; document.getElementById('pauseOverlay').classList.toggle('show', paused);
      paused? SFX.pause(): SFX.unpause();
      if(aiEnabled && !paused && !gameover){ scheduleNextAiMove(); }
    }

    function holdPiece(){ if(holdLocked) return; holdLocked=true; [hold, piece] = [ piece, hold? {...hold, x:3, y:18, rot:0 } : newPiece() ]; refreshActiveMeshes(); refreshGhost(); drawMiniCanvases(); SFX.hold(); }

    function hardDrop(fromAI=false){ const g=projectGhost(piece); piece.y=g.y; if(!fromAI) SFX.drop(); placePiece(); }

    function placePiece(){
      let isGameOver = false;
      forEachBlock(piece,(x,y)=>{
        if (y >= ROWS) { isGameOver = true; }
        if(y < ROWS) { board[y][x]=piece.color; addCubeToStack(x,y,piece.color); }
      });

      // Efeitos de impacto no assentar
      Feel.triggerShake(90);
      SFX.lock();

      if (isGameOver) { endGame(); return; }

      const cleared=clearLines();
      onLinesCleared(cleared);

      piece = newPiece(); holdLocked=false;
      refreshActiveMeshes(); refreshGhost();
      drawMiniCanvases();

      if (aiEnabled && !gameover) { scheduleNextAiMove(); }
    }

    /* =====================================================================
       MAIN LOOP / UPDATE
       ===================================================================== */
    function update(dt){
      if(paused || aiEnabled || gameover) return;

      // Auto-shift simples (repeti√ß√£o de setas)
      if (heldKeys.has('ArrowLeft'))  tryMove(-1);
      if (heldKeys.has('ArrowRight')) tryMove(1);

      dropAcc += dt * (softDrop? 10:1);
      if(dropAcc > dropMs){ dropAcc=0; if(canMove(piece,0,-1)){ piece.y--; refreshActiveMeshes(); } else { placePiece(); } }

      Feel.update(dt);
    }

    let last=performance.now(); let fpsAcc=0, fpsCount=0, fpsVal=0;
    function loop(){
      requestAnimationFrame(loop);
      const now=performance.now(); const dt=now-last; last=now;
      if (!paused && !gameover) pollGamepad();
      update(dt);
      renderer.setClearColor(new THREE.Color(0x0a0d1a).lerp(new THREE.Color(0x1a1f3a), flashIntensity*0.6));
      renderer.render(scene, camera);

      // FPS
      fpsAcc += dt; fpsCount++; if (fpsAcc>500){ fpsVal = Math.round(1000/(fpsAcc/fpsCount)); fpsAcc=0; fpsCount=0; updateStats(); }
    }

    /* =====================================================================
       HUD / PREVIEWS / STATS
       ===================================================================== */
    function updateHUD(){
      document.getElementById('score').textContent=score;
      document.getElementById('lines').textContent=lines;
      document.getElementById('level').textContent=level;
      const speedMul=(DROP_BASE_MS/dropMs).toFixed(2)+'x'; document.getElementById('speed').textContent=speedMul;
      document.getElementById('combo').textContent=combo;
      document.getElementById('hiscore').textContent=hiscore;
    }

    function drawMini(can, type){
      const ctx=can.getContext('2d'); ctx.clearRect(0,0,can.width,can.height); if (!type) { return; }
      const size=22; const offX=can.width/2, offY=can.height/2; const blocks=SHAPES[type][0];
      const minX=Math.min(...blocks.map(b=>b[0])), maxX=Math.max(...blocks.map(b=>b[0]));
      const minY=Math.min(...blocks.map(b=>b[1])), maxY=Math.max(...blocks.map(b=>b[1]));
      const w=(maxX-minX+1)*size, h=(maxY-minY+1)*size; const startX=offX-w/2, startY=offY-h/2;
      ctx.fillStyle='#9fb6ff'; ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1;
      blocks.forEach(([bx,by])=>{ const x=startX+(bx-minX)*size, y=startY+(by-minY)*size; ctx.fillRect(x+1,y+1,size-2,size-2); ctx.strokeRect(x+0.5,y+0.5,size-1,size-1); });
    }

    function drawMiniCanvases(){ const nextType=peekNext(); drawMini(document.getElementById('nextCanvas'), nextType); drawMini(document.getElementById('holdCanvas'), hold? hold.type : null); }

    function updateStats(){
      const t = Math.max(0, performance.now() - startTime); const sec = Math.floor(t/1000);
      const min = Math.floor(sec/60); const s = sec%60; const playtime = `${min}:${String(s).padStart(2,'0')}`;
      document.getElementById('playtime').textContent = playtime;
      // A√ß√µes por minuto (APM) ‚Äî base simples nos √∫ltimos 30s
      lastActions = lastActions.filter(t=> performance.now()-t < 30000);
      apm = Math.round( lastActions.length / 0.5 );
      document.getElementById('apm').textContent = apm;
      document.getElementById('pieces').textContent = piecesCount;
      document.getElementById('fps').textContent = fpsVal;
    }

    function markAction(){ lastActions.push(performance.now()); }

    document.getElementById('restartBtn').addEventListener('click', ()=>restart());

    function restart(){
      if(aiTimer) clearTimeout(aiTimer); aiTimer = null;
      aiToggle.checked = false; aiEnabled = false;
      board = Array.from({length: ROWS}, ()=>Array(COLS).fill(null));
      while(stackGroup.children.length) stackGroup.remove(stackGroup.children[0]);
      while(fxGroup.children.length) fxGroup.remove(fxGroup.children[0]);
      piecesCount=0;
      piece=newPiece();
      hold=null; holdLocked=false; score=0; lines=0; level=1; combo=0; dropMs=DROP_BASE_MS; dropAcc=0; softDrop=false; gameover=false; paused=false; 
      refreshActiveMeshes(); refreshGhost(); updateHUD(); drawMiniCanvases();
      document.getElementById('gameover').style.display='none';
      document.getElementById('pauseOverlay').classList.remove('show');
      startTime = performance.now(); lastActions = []; updateStats();
      uiBeep(600,0.07);
    }

    /* =====================================================================
       TEMA CLARO/ESCURO (apenas trocas de vari√°veis CSS)
       ===================================================================== */
    let themeAlt=false;
    function toggleTheme(){
      themeAlt = !themeAlt;
      const root = document.documentElement;
      if (themeAlt){
        root.style.setProperty('--bg1', '#0b0e13');
        root.style.setProperty('--ui-bg', '#0f1326');
        root.style.setProperty('--ui-border', 'rgba(122,162,255,.28)');
        root.style.setProperty('--accent', '#8ab4ff');
      } else {
        root.style.setProperty('--bg1', '#0a0d1a');
        root.style.setProperty('--ui-bg', '#111529');
        root.style.setProperty('--ui-border', 'rgba(122,162,255,.25)');
        root.style.setProperty('--accent', '#7aa2ff');
      }
      uiBeep(500,0.05);
    }

    /* =====================================================================
       UI ‚Äî Volumes e feel sliders
       ===================================================================== */
    const musicVolEl = document.getElementById('musicVol');
    const sfxVolEl = document.getElementById('sfxVol');

    musicVolEl.addEventListener('input', ()=>{ musicVol = musicVolEl.value/100; uiBeep(480 + musicVol*200, 0.03); });
    sfxVolEl.addEventListener('input', ()=>{ SFX.vol = sfxVolEl.value/100; SFX.move(); });

    // Ajustes de feel
    document.getElementById('shakeStrength').addEventListener('input', ()=>{ Feel.shakeAmp = 0.02 + 0.12 * (document.getElementById('shakeStrength').value/100); });
    document.getElementById('squashStrength').addEventListener('input', ()=>{ /* j√° lido no addSquash (efeito opcional) */ });
    document.getElementById('flashStrength').addEventListener('input', ()=>{ /* intensidade lida em clearLines */ });

    /* =====================================================================
       TOAST / FEEDBACK
       ===================================================================== */
    let toastTimer=null; function toast(msg, ms=1200){ const el=document.getElementById('toast'); el.textContent=msg; el.classList.add('show'); if(toastTimer) clearTimeout(toastTimer); toastTimer=setTimeout(()=>el.classList.remove('show'), ms); }

    /* =====================================================================
       INICIALIZA√á√ÉO
       ===================================================================== */
    fitOrtho(); updateAiSpeed(); refreshActiveMeshes(); refreshGhost(); updateHUD(); drawMiniCanvases();
    document.getElementById('hiscore').textContent=hiscore;
    loop();

    // Estado inicial dos toggles
    document.getElementById('btnSfx').setAttribute('aria-pressed', String(sfxOn));

    // Guardas r√°pidas
    window.addEventListener('blur', ()=>{ if(!paused && !gameover) { togglePause(); } });

    // Expor algumas fun√ß√µes √∫teis no console (debug)
    window.T2D = { restart, startMusic, stopMusic };

  </script>
</body>
</html>
